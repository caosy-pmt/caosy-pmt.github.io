<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://caosy-pmt.github.io</id>
    <title>Gridea</title>
    <updated>2021-07-07T15:58:30.628Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://caosy-pmt.github.io"/>
    <link rel="self" href="https://caosy-pmt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://caosy-pmt.github.io/images/avatar.png</logo>
    <icon>https://caosy-pmt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[# Spring 学习随笔]]></title>
        <id>https://caosy-pmt.github.io/post/spring-xue-xi-sui-bi/</id>
        <link href="https://caosy-pmt.github.io/post/spring-xue-xi-sui-bi/">
        </link>
        <updated>2021-07-07T09:17:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一章-对spring的总体印象"><strong>第一章、对Spring的总体印象</strong></h2>
<p>1、Spring是一个框架，核心技术有ioc（控制反转）、aop（面向切面编程），用来代码解耦合。</p>
<p>2、Spring是一个容器，存放的是java对象，用于对java对象的创建、管理等，我们在程序中从这<br>
个容器获得要使用的对象。</p>
<p>3、存放的java对象有dao类、service类、controler类、工具类，通过两种方式：<br>
（1）xml配置，使用<code>&lt;bean&gt;</code><br>
（2）注解</p>
<p>4、不存放的对象有实体类（数据库）、servlet、listener、filter（放Tomcat服务器里）。</p>
<hr>
<h2 id="第二章-ioc控制反转"><strong>第二章、IOC控制反转</strong></h2>
<h3 id="21-ioc的概念"><strong>2.1 ioc的概念</strong></h3>
<p>1、IoC (Inversion of Control) : 控制反转，是一个理论、概念、思想。<br>
控制：创建对象、给对象赋值、管理对象之间的关系；<br>
反转：之前开发总是在程序中，开发人员直接去控制，现在将开发人员的这个控制的权限、任务都交给容器来完成、实现。</p>
<p>2、IoC的技术实现：DI（Dependency Injection），依赖注入，只需要在程序中提供要使用的对象名称就可以， 至于对象如何在容器中创建，赋值，查找都由容器内部实现。</p>
<hr>
<h3 id="22-开发步骤"><strong>2.2、开发步骤</strong></h3>
<p>引入maven依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>接口、类等的实现--&gt;resources目录--&gt;Spring配置文件（Idea自带）</p>
<hr>
<h3 id="23-基于xml的di"><strong>2.3、基于XML的DI</strong></h3>
<h4 id="231-set注入">2.3.1、set注入</h4>
<pre><code>1、首先在所构造对象的类中实现其setter()方法；
2、使用Spring配置文件的&lt;bean/&gt;,&lt;property/&gt;标签
***
&lt;bean id=&quot;myschool&quot; class=&quot;com.csy.ba01.School&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;安大&quot;/&gt;
    &lt;property name=&quot;address&quot; value=&quot;安徽合肥&quot;/&gt;
&lt;/bean&gt;
***
</code></pre>
<p>😀id：为该配置文件中唯一的名称，不可重起一行<code>&lt;bean/&gt;</code>用相同的id，用户自定义，用来唯一标识某对象。<br>
😀class：该对象的全限定类名。<br>
😀<code>&lt;property/&gt;</code>：name为类的属性名称，容器读到这里会自动调用Setter方法将(简单类型value)或者(引用类型ref)值赋给相应属性。<br>
😀Spring容器一般会先调用无参构造函数构造一个对象，再调用Setter函数。</p>
<h4 id="232-构造注入">2.3.2、构造注入</h4>
<pre><code>1、首先在相应类中实现其带参构造函数，这里注意大部分情况下要同时实现无参构造，否则当同时使
用set注入时会报错，若不写带参构造则无参构造则不必手写，系统会自动实现。
2、使用Spring配置文件的&lt;bean/&gt;,&lt;constructor-arg/&gt;标签
***
&lt;bean id=&quot;myschool1&quot; class=&quot;com.csy.ba01.School&quot;&gt;
    &lt;constructor-arg name=&quot;address&quot; value=&quot;安徽合肥&quot;/&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;中科大&quot;/&gt;
&lt;/bean&gt;
***
语法跟set类似
</code></pre>
<h4 id="233-创建对象">2.3.3、创建对象</h4>
<p>1、容器接口和实现类<br>
ApplicationContext 接口用于加载 Spring 的配置文件，在程序中充当“容器”的角色。其实现类有两个：ClassPathXmlApplicationContext()、FileSystemXmlApplicationContext()，通常用前者，参数为resources目录下的所需的配置文件的路径，以字符串形式。</p>
<p>2、ApplicationContext 容器中对象的装配时机，ApplicationContext 容器，会在容器对象初始化时，将其中的所有对象一次性全部装配好。以后代码中若要使用到这些对象，只需从内存中直接获取即可。执行效率较高。但占用内存。</p>
<pre><code>//测试
public void test04(){
    String resource = &quot;ba02/applicationContext.xml&quot;;
    ApplicationContext act = new ClassPathXmlApplicationContext(resource);
    Student stu = (Student) act.getBean(&quot;mystudent&quot;);
    System.out.println(&quot;学生&quot;+stu);
 }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java重新写sort函数]]></title>
        <id>https://caosy-pmt.github.io/post/java-chong-xin-xie-sort-han-shu-de-jie-ding-fang-fa/</id>
        <link href="https://caosy-pmt.github.io/post/java-chong-xin-xie-sort-han-shu-de-jie-ding-fang-fa/">
        </link>
        <updated>2021-07-05T07:52:23.000Z</updated>
        <content type="html"><![CDATA[<p><em><strong>操作list：重写Collections.sort()</strong></em></p>
<pre><code>Collections.sort(list, new Comparator&lt;Integer&gt;() { 
    //list即为要排序的列表；Integer为列表存放的数据类型，也即要排序数据的数据类型
    			public int compare(Integer a, Integer b) {
    				return b-a;//此处为降序，a-b为升序
    			}	
    		});
</code></pre>
<p><em><strong>操作数组：重写Arrays.sort()</strong></em></p>
<pre><code>Arrays.sort(test, new Comparator&lt;int[]&gt;() {
    //test为二维数组，按照各一维数组的第一个数大小来排序
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0]-o2[0];
            }
        });
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[# MyBatis学习随笔]]></title>
        <id>https://caosy-pmt.github.io/post/mybatis-xue-xi-sui-bi/</id>
        <link href="https://caosy-pmt.github.io/post/mybatis-xue-xi-sui-bi/">
        </link>
        <updated>2021-07-03T07:22:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="idea常用快捷键"><em><strong>idea常用快捷键</strong></em></h3>
<pre><code>1、Ctrl+D 复制当前行到下一行 
2、Ctrl+N 查看当前类的信息; Ctrl+H实现当前类的; Ctrl+B 快速打开光标处的类或方法
3、Alt+0(insert) 实体类快速生成相应函数 
4、Ctrl+R 全局替换 
5、Ctrl+F 查找文本
6、Ctrl+P 方法参数提示
7、Ctrl+X 删除行
8、Ctrl+/ 或 Ctrl+Shift+/  注释（// 或者/*...*/ ）
9、Ctrl+J 自动代码（常见的代码片段）
10、Shift+F6 重命名
11、sout 快速打出System.out.Println()；
    main/psvm 快速打出public static void main（String args[])
12、Ctrl+Alt+O 快速清除多余包、自动导包
13、Ctrl+P 查看方法参数
</code></pre>
<hr>
<h3 id="jdbc的冗余性"><em><strong>JDBC的冗余性</strong></em></h3>
<pre><code>public void findStudent() {
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        //注册 mysql 驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //连接数据的基本信息 url ，username，password
        String url = &quot;jdbc:mysql://localhost:3306/springdb&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;
        //创建连接对象
         conn = DriverManager.getConnection(url, username, password);
        //保存查询结果
        List&lt;Student&gt; stuList = new ArrayList&lt;&gt;();
        //创建 Statement, 用来执行 sql 语句
        stmt = conn.createStatement();
        //执行查询，创建记录集，
        rs = stmt.executeQuery(&quot;select * from student&quot;);
        while (rs.next()) {
            Student stu = new Student();
            stu.setId(rs.getInt(&quot;id&quot;));
            stu.setName(rs.getString(&quot;name&quot;));
            stu.setAge(rs.getInt(&quot;age&quot;));
            //从数据库取出数据转为 Student 对象，封装到 List 集合
            stuList.add(stu);
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            //关闭资源
                if (rs != null)  {
                     rs.close();
                 }
                if (stmt != null) {
                    stmt.close();
                }
                if (conn != null) {
                    conn.close();
                }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<hr>
<h3 id="准备工作"><em><strong>准备工作</strong></em></h3>
<p><strong>1、设置源根resources</strong><br>
新建项目时，要设置源根resources,后续用于存放mybatis主配置文件，且只有为源根时，compile后target文件中才会有resources。</p>
<p><strong>2、maven依赖</strong></p>
<pre><code>        &lt;!-- MyBatis依赖   --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;3.5.1&lt;/version&gt;
    &lt;/dependency&gt;，
        &lt;!-- Mysql驱动   --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;5.1.9&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre>
<p><strong>3、maven插件</strong><br>
扫描java目录下的全部properties、xml文件--&gt;target</p>
<pre><code>&lt;resource&gt;
 &lt;directory&gt;src/main/java&lt;/directory&gt;&lt;!--所在的目录--&gt;
 &lt;includes&gt;&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;
 &lt;include&gt;**/*.properties&lt;/include&gt;
 &lt;include&gt;**/*.xml&lt;/include&gt;
 &lt;/includes&gt;
 &lt;filtering&gt;false&lt;/filtering&gt;
&lt;/resource&gt;
</code></pre>
<hr>
<h3 id="配置文件xml"><em><strong>配置文件.xml</strong></em></h3>
<p>😀创建数据库--&gt;实体类--&gt;Dao接口、接口里方法声明--&gt;配置文件；<br>
😀idea的自定义代码模板：设置--&gt;编辑器--&gt;代码样式--&gt;文件和代码模板--&gt;&quot;+&quot;。</p>
<p><strong>1、Dao 接口 Mapper 映射文件</strong></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;同名dao接口的全限定名称&quot;&gt;
    &lt;select id=&quot;dao接口中的方法名&quot; resultType=&quot;&quot;&gt;
        
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<p><strong>2、mybatis主配置文件</strong><br>
😀properties文件灵活配置连接需要的数据（数据库基本信息）；<br>
😀设置mybatis输出日志，便于调试；<br>
😀sql mapper(sql映射文件)的位置的俩种表示：resource、package</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;

    &lt;!--指定properties文件的位置，从类路径根开始找文件，灵活配置下面连接需要的数据--&gt;
    &lt;properties resource=&quot;jdbc.properties&quot; /&gt;

    &lt;!--settings：控制mybatis全局行为--&gt;
    &lt;settings&gt;
        &lt;!--mybatis输出日志--&gt;
        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
    &lt;/settings&gt;

    &lt;environments default=&quot;mydev&quot;&gt;
        &lt;environment id=&quot;mydev&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!--从jdbc.properties中得到数据库的驱动类名--&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;!--连接数据库的url字符串--&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;!--访问数据库的用户名--&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;!--密码--&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.passwd}&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- sql mapper(sql映射文件)的位置--&gt;
    &lt;mappers&gt;
        &lt;!--第一种方式：指定多个mapper文件--&gt;
        &lt;!--&lt;mapper resource=&quot;com/bjpowernode/dao/StudentDao.xml&quot;/&gt;
        &lt;mapper resource=&quot;com/bjpowernode/dao/OrderDao.xml&quot; /&gt;--&gt;

        &lt;!--第二种方式： 使用包名
            name: xml文件（mapper文件）所在的包名, 这个包中所有xml文件一次都能加载给mybatis
            使用package的要求：
             1. mapper文件名称需要和接口名称一样， 区分大小写的一样
             2. mapper文件和dao接口需要在同一目录
        --&gt;
        &lt;package name=&quot;com.csy.dao&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;

</code></pre>
<hr>
<h3 id="常用代码可写一个工具类util"><em><strong>常用代码可写一个工具类util</strong></em></h3>
<p>😀获取SqlSession对象</p>
<pre><code>public class SqlSessionUtil {
    //定义 SqlSessionFactory
    private static SqlSessionFactory factory = null;
    static {
        //使用 静态块 创建一次 SqlSessionFactory
        try{
            😀String config = &quot;mybatis.xml&quot;;
            //读取配置文件
            InputStream in = Resources.getResourceAsStream(config);
            //创建 SqlSessionFactory 对象
            factory = new SqlSessionFactoryBuilder().build(in);
        }catch (Exception e){
            factory = null;
            e.printStackTrace();
        }
    }
    /* 获取 SqlSession 对象 */
    public static SqlSession getSqlSession(){
        SqlSession session = null;
        if( factory != null){
            session = factory.openSession();
        }
        return session;
    }
}
</code></pre>
<hr>
<h3 id="动态代理"><em><strong>动态代理</strong></em></h3>
<p><strong>1、传统的Dao开发</strong><br>
需要创建实现类，再实现Dao接口的方法，获取SqlSession后会直接调用SqlSession中的增删改查方法，参数至少（除查外都有其他参数）为Dao接口中具体方法的全限定名称，代码冗余性极大，会有很多相似的代码。<br>
<strong>2、动态代理</strong><br>
会调用其getMapper(接口名.class)方法，动态生成代理对象，该对象可调用Dao接口类中与mapper文件中”id“同名的方法，去执行从mapper文件中的sql语句，并得到相应的结果对象（jdbc中的一系列操作）。以下动态代理方法：</p>
<pre><code>public void selectAllStudentsTest(){
        SqlSession sqlSession = SqlSessionUtil.getSqlSession();
        StudentDao dao = sqlSession.getMapper(StudentDao.class);
        List&lt;Student&gt; stus =dao.selectAllStudents();
        for(Student stu:stus){
            System.out.println(&quot;学生&quot;+stu);
        }
        sqlSession.close();
    }
</code></pre>
<hr>
<h3 id="mybatis传递参数"><em><strong>mybatis传递参数</strong></em></h3>
<p>从 java 代码中把参数传递到 mapper.xml 文件。</p>
<p><strong>1、一个简单参数</strong><br>
使用#{id}占位符，其中id可为任意值：<br>
<code>select * from student where id=#{StudentId}</code></p>
<p><strong>2、多个参数</strong><br>
（1）使用@Param<br>
mappe文件通过使用与Dao接口方法中的相同名称的形参来使用参数，即在方法形参前面加入@Param(“自定义参数名”)，mapper 文件使用#{自定义参数名}。<br>
😀接口方法：</p>
<pre><code>public List&lt;Student&gt; selectStudentsByIdAndAge(@Param(&quot;studentId&quot;) int id,
                                            @Param(&quot;studentAge&quot;) int age);
</code></pre>
<p>😀mapper文件：</p>
<pre><code>    &lt;select id=&quot;selectStudentsByIdAndAge&quot; resultType=&quot;com.csy.entity.Student&quot;&gt;
        select * from student where id&gt;#{studentId} and age&gt;#{studentAge}
    &lt;/select&gt;
</code></pre>
<p>(2) 使用对象<br>
Dao接口方法的形参为对象，此时mapper文件中的#{}中直接写该对象的相应属性<br>
😀接口方法：</p>
<pre><code>public int insertOneStudent(Student stu);
</code></pre>
<p>😀mapper文件：</p>
<pre><code>&lt;insert id=&quot;insertOneStudent&quot; &gt;
        insert into student(id,name,email,age) values(#{id},#{name},#{email},#{age})
&lt;/insert&gt;
</code></pre>
<p><strong>3、<code>#</code>与<code>$</code>的区别</strong><br>
（1）<code>#</code>是占位符，使用？做占位，mybatis内部调用PreparedStatement对象执行sql语句，效率高；<br>
（2）<code>#</code>表示列的值，一般放在等号的右侧使用；<br>
（3）<code>$</code>是字符串代理连接，把sql语句和<code>$</code>{}位置的值连接在一起组成新的语句；<br>
（4）<code>$</code>所表示的内容是原样替换的<br>
（5）<code>$</code>使用的sql语句，mybatis使用的是Statement对象执行sql；<br>
（6）<code>$</code>一般是常用作替换表名、列名等，不做值的使用。<br>
😀<code>$</code>的常规用法：<br>
接口方法：</p>
<pre><code>Student findByDiffField(@Param(&quot;col&quot;) String colunName,@Param(&quot;cval&quot;) Object 
value);
</code></pre>
<p>mapper 文件：</p>
<pre><code>&lt;select id=&quot;findByDiffField&quot; resultType=&quot;com.bjpowernode.domain.Student&quot;&gt;
 select * from student where ${col} = #{cval}
&lt;/select&gt;
</code></pre>
<hr>
<h3 id="mybatis输出结果"><em><strong>mybatis输出结果</strong></em></h3>
<p><strong>（一）resultType</strong></p>
<p><strong>1、简单类型（int、String...)</strong></p>
<p><strong>2、对象类型</strong></p>
<p><strong>3、map</strong><br>
sql 的查询结果作为 Map 的 key 和 value。推荐使用 Map&lt;Object,Object&gt;。<br>
注意：Map 作为接口返回值，sql 语句的查询结果最多只能有一条记录。大于一条记录是错误。</p>
<p>接口方法：<br>
<code>Map&lt;Object,Object&gt; selectReturnMap(int id);</code></p>
<p>mapper 文件：</p>
<pre><code>&lt;select id=&quot;selectReturnMap&quot; resultType=&quot;java.util.HashMap&quot;&gt;
 select * from student where id = #{studentId}
&lt;/select&gt;
</code></pre>
<p>测试结果：<br>
<code>map对象：{name=张飞, id=1003, email=zf@163.com, age=19}</code></p>
<p><strong>（二）resultMap</strong></p>
<p>常用于数据库列名与java类中的属性名不一致时（不常用），通常情况下我们都会将其设为一致。</p>
<p>此处示范一下：</p>
<p>接口方法：<br>
`List<Student> selectUseResultMap(QueryParam param);</p>
<p>mapper 文件：</p>
<pre><code>&lt;!-- 创建 resultMap
    id:自定义的唯一名称，在&lt;select&gt;使用
    type:期望转为的 java 对象的全限定名称或别名 --&gt;

&lt;resultMap id=&quot;studentMap&quot; type=&quot;com.bjpowernode.domain.Student&quot;&gt;
    &lt;!-- 主键字段使用 id --&gt;
    &lt;id column=&quot;id&quot; property=&quot;stuid&quot; /&gt;
    &lt;!--非主键字段使用 result--&gt;
    &lt;result column=&quot;name&quot; property=&quot;stuname&quot;/&gt;
    &lt;result column=&quot;email&quot; property=&quot;stuemail&quot; /&gt;
    &lt;result column=&quot;age&quot; property=&quot;stuage&quot; /&gt;
&lt;/resultMap&gt;

&lt;!--resultMap: resultMap 标签中的 id 属性值--&gt;
&lt;select id=&quot;selectUseResultMap&quot; resultMap=&quot;studentMap&quot;&gt;
    select id,name,email,age from student where name=#{queryName} or age=#
{queryAge}
&lt;/select&gt;
</code></pre>
<p>其中column为数据库列名，property为输出的java类对象的属性名。</p>
<p>如果要使用resultType处理此种情况，可使用列别名，在sql语句中加入一些东西：<br>
<code>select id as stuid, name as stuname,age as stuage,email as stueamil from student</code></p>
<hr>
<h3 id="模糊查询-like"><em><strong>模糊查询 like</strong></em></h3>
<p><strong>1、在java代码中的参数入手</strong></p>
<p>sql语句：<br>
<code>select * from student where name like #{参数}</code><br>
这里的参数例如为`“李%”。</p>
<p><strong>2、在mapper文件的sql语句里直接加</strong></p>
<p>sql语句：<br>
<code>select * from student where name like #{参数} &quot;%&quot;</code><br>
这里的参数为<code>“李”</code>,要注意使用空格隔开参数与%。</p>
<hr>
<h3 id="动态sql"><em><strong>动态Sql</strong></em></h3>
<p>主要是通过常用的动态 SQL 标签有<code>&lt;if&gt;、&lt;where&gt;、&lt;foreach&gt;</code>来动态拼接sql语句。</p>
<p><strong>1、<code>&lt;if&gt; 与 &lt;where&gt;</code></strong><br>
<code>&lt;if&gt;</code>单独使用时最前面需要加一个恒等式，保证后面的连接词（and、or...)不会报错，所以常常会与<code>&lt;where&gt;</code>标签连用。</p>
<p>接口方法：<br>
<code>List&lt;Student&gt; selectStudentsSqlIf2(@Param(&quot;stuName&quot;) String name,@Param(&quot;stuAge&quot;) int age);</code></p>
<p>单独的if-sql语句：</p>
<pre><code>select id,name,email,age from student
        where 1=1
        &lt;if test=&quot;stuName != null and stuName !='' &quot;&gt;
            and name = #{stuName}
        &lt;/if&gt;
        &lt;if test=&quot;stuAge &gt; 0 &quot;&gt;
            and age &amp;gt; #{stuAge}
        &lt;/if&gt;
</code></pre>
<p>上述为简单类型参数，若为对象类型参数，test中可直接使用java类的属性名，由mybatis去get。</p>
<p>if-where Sql语句：将<code>where 恒等式（1=1）</code>改为 <code>&lt;where&gt;&lt;/where&gt;</code>包住if语句</p>
<p><strong>2、<code>&lt;foreach&gt;</code></strong></p>
<p>接口方法：<br>
<code>List&lt;Student&gt; selectStudentsByForeach(List&lt;Integer&gt; idList);</code></p>
<p>mapper 文件：</p>
<pre><code>    &lt;select id=&quot;selectStudentsByForeach2&quot; resultType=&quot;com.csy.entity.Student&quot;&gt;
        select id,name,email,age from student
        &lt;if test=&quot;array.length&gt;0 &quot;&gt;
            /*test中使用@Param可用自己设置的名称（idList）,否则只能是list、array交给mybatis自己去找集合*/
            where id in
            &lt;foreach collection=&quot;array&quot; item=&quot;stuId&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot;&gt;
                  /*此处collection 与前面的test要一致*/
                #{stuId}
            &lt;/foreach&gt;
        &lt;/if&gt;
    &lt;/select&gt;
</code></pre>
<p>注意foreach各参数间用空格隔开，item=&quot;集合中的成员&quot;，open、close、separator分别表示所插入sql片段的开始、结束及分割符。</p>
<p><strong>3、Sql代码片段</strong></p>
<p>mapper 文件：</p>
<pre><code>&lt;!--创建 sql 片段 id:片段的自定义名称--&gt;
&lt;sql id=&quot;studentSql&quot;&gt;
 select id,name,email,age from student
&lt;/sql&gt;

&lt;!-- 引用 sql 片段 --&gt;
 &lt;include refid=&quot;studentSql&quot;/&gt; /*代替之前定义的代码片段*/
</code></pre>
<hr>
<h3 id="基于-pagehelper-分页"><em><strong>基于 PageHelper 分页</strong></em></h3>
<p><strong>1、maven坐标</strong></p>
<pre><code>&lt;dependency&gt;
 &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;
 &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;
 &lt;version&gt;5.1.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>2、加入 plugin 配置</strong></p>
<pre><code>在&lt;environments&gt;之前加入
&lt;plugins&gt;
 &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot; /&gt;
&lt;/plugins&gt;
</code></pre>
<p><strong>3、用法</strong></p>
<p>查询语句之前调用 PageHelper.startPage （,）静态方法。，紧跟在这个方法后的第一个 MyBatis 查询方法会被进行分页。</p>
<p>//获取第 1 页，3 条内容<br>
<code>PageHelper.startPage(1,3);</code></p>
]]></content>
    </entry>
</feed>